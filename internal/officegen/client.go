package officegen

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"strings"
)

type Client struct {
	llmURL string
}

func NewClient(llmURL string) *Client {
	return &Client{
		llmURL: llmURL,
	}
}

func (c *Client) GenerateDocument(prompt string, targetPages int, includeImages bool) (*DocumentContent, error) {
	targetWords := targetPages * 500
	if targetWords == 0 {
		targetWords = 1500
	}

	imageDirective := ""
	if includeImages {
		imageDirective = "\n- Also suggest 2-3 relevant image descriptions for illustrations"
	}

	systemPrompt := fmt.Sprintf(`Generate a structured document about: %s

Requirements:
- Target length: approximately %d words
- Include: introduction, main sections with detailed paragraphs, conclusion
- Structure each section with a clear heading%s

IMPORTANT: Return ONLY valid JSON with no markdown formatting, code blocks, or explanatory text.

Return in this exact format:
{
  "title": "Document Title",
  "sections": [
    {"heading": "Section 1", "content": "Detailed paragraph text..."},
    {"heading": "Section 2", "content": "More content..."}
  ]
}`, prompt, targetWords, imageDirective)

	response, err := c.callLLM(systemPrompt)
	if err != nil {
		return nil, err
	}

	cleanedResponse := cleanJSONResponse(response)

	var content DocumentContent
	if err := json.Unmarshal([]byte(cleanedResponse), &content); err != nil {
		slog.Warn("Failed to parse JSON response, creating basic structure", "error", err, "response", cleanedResponse[:min(200, len(cleanedResponse))])
		content = DocumentContent{
			Title: prompt,
			Sections: []DocumentSection{
				{Heading: "Content", Content: response},
			},
		}
	}

	return &content, nil
}

func (c *Client) GenerateSpreadsheet(prompt string) (*SpreadsheetContent, error) {
	systemPrompt := fmt.Sprintf(`Generate spreadsheet data about: %s

Requirements:
- Organize data into multiple logical sheets (2-4 sheets)
- Each sheet should have clear headers and at least 5-10 rows of data
- Include realistic data values

IMPORTANT: Return ONLY valid JSON with no markdown formatting, code blocks, or explanatory text.

Return in this exact format:
{
  "title": "Spreadsheet Title",
  "sheets": [
    {
      "name": "Sheet1",
      "headers": ["Column1", "Column2", "Column3"],
      "rows": [
        ["value1", "value2", "value3"],
        ["value4", "value5", "value6"]
      ]
    }
  ]
}`, prompt)

	response, err := c.callLLM(systemPrompt)
	if err != nil {
		return nil, err
	}

	cleanedResponse := cleanJSONResponse(response)

	var content SpreadsheetContent
	if err := json.Unmarshal([]byte(cleanedResponse), &content); err != nil {
		slog.Warn("Failed to parse JSON response, creating basic structure", "error", err, "response", cleanedResponse[:min(200, len(cleanedResponse))])
		content = SpreadsheetContent{
			Title: prompt,
			Sheets: []SpreadsheetData{
				{
					Name:    "Data",
					Headers: []string{"Item", "Value"},
					Rows:    [][]string{{"Generated content", response[:min(100, len(response))]}},
				},
			},
		}
	}

	return &content, nil
}

func (c *Client) GeneratePresentation(prompt string, targetSlides int) (*PresentationContent, error) {
	if targetSlides == 0 {
		targetSlides = 5
	}

	systemPrompt := fmt.Sprintf(`Generate a %d-slide presentation outline about: %s

Requirements:
- Include a title and subtitle for the presentation
- Create %d content slides (excluding title slide)
- Each slide MUST have a non-empty title and 3-5 bullet points
- Keep bullet points concise (one sentence each)
- NEVER create empty slides or slides with blank titles

IMPORTANT: Return ONLY valid JSON with no markdown formatting, code blocks, or explanatory text.

Return in this exact format:
{
  "title": "Presentation Title",
  "subtitle": "Subtitle or tagline",
  "slides": [
    {
      "title": "Slide 1 Title",
      "bullets": ["Point 1", "Point 2", "Point 3"]
    }
  ]
}`, targetSlides, prompt, targetSlides)

	response, err := c.callLLM(systemPrompt)
	if err != nil {
		return nil, err
	}

	cleanedResponse := cleanJSONResponse(response)

	var content PresentationContent
	if err := json.Unmarshal([]byte(cleanedResponse), &content); err != nil {
		slog.Warn("Failed to parse JSON response, creating basic structure", "error", err, "response", cleanedResponse[:min(200, len(cleanedResponse))])
		content = PresentationContent{
			Title:    prompt,
			Subtitle: "Generated by AI",
			Slides: []PresentationSlide{
				{Title: "Content", Bullets: []string{response[:min(100, len(response))]}},
			},
		}
	} else {
		slog.Info("Parsed presentation content", "title", content.Title, "slides", len(content.Slides))
		for i, slide := range content.Slides {
			slog.Info("Slide content", "index", i, "title", slide.Title, "bullets", len(slide.Bullets))
		}
	}

	return &content, nil
}

func cleanJSONResponse(response string) string {
	response = strings.TrimSpace(response)

	if strings.HasPrefix(response, "```json") {
		response = strings.TrimPrefix(response, "```json")
	} else if strings.HasPrefix(response, "```") {
		response = strings.TrimPrefix(response, "```")
	}

	if strings.HasSuffix(response, "```") {
		response = strings.TrimSuffix(response, "```")
	}

	return strings.TrimSpace(response)
}

func (c *Client) GenerateText(prompt string) (string, error) {
	return c.callLLM(prompt)
}

func (c *Client) callLLM(prompt string) (string, error) {
	requestBody := map[string]any{
		"model": "llama",
		"messages": []map[string]string{
			{"role": "user", "content": prompt},
		},
	}

	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return "", err
	}

	resp, err := http.Post(c.llmURL+"/v1/chat/completions", "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	var response map[string]any
	if err := json.Unmarshal(body, &response); err != nil {
		return "", err
	}

	choices, ok := response["choices"].([]any)
	if !ok || len(choices) == 0 {
		return "", fmt.Errorf("invalid response from AI server")
	}

	choice, ok := choices[0].(map[string]any)
	if !ok {
		return "", fmt.Errorf("invalid response structure")
	}

	message, ok := choice["message"].(map[string]any)
	if !ok {
		return "", fmt.Errorf("invalid message structure")
	}

	content, ok := message["content"].(string)
	if !ok {
		return "", fmt.Errorf("invalid content")
	}

	return content, nil
}
